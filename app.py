#!/usr/bin/env python3
# app.py - Flask Web Application

import time
import datetime
import logging
import json
import sys
from flask import Flask, request, render_template, url_for, Response, stream_with_context, jsonify

from core_logic import (
    RDKIT_AVAILABLE, SMARTS_LIBRARY_DATA, get_smarts_categories,
    find_candidates_by_structure,
    filter_candidates_by_nmr,
    fetch_compound_details
)
from typing import List, Optional, Generator, Callable, Any, Dict, Tuple

# --- Flask App Initialization ---
app = Flask(__name__)
app.secret_key = 'dev-secret-key-replace-me'

# --- Web Specific Constants ---
MAX_CIDS_SUMMARY = 100
MAX_DETAILS_TO_SHOW = 4
DETAIL_IMAGE_WIDTH = 250
DETAIL_IMAGE_HEIGHT = 250

SMARTS_CATEGORIES = get_smarts_categories(SMARTS_LIBRARY_DATA)

@app.context_processor
def inject_global_vars():
    return dict(
        rdkit_available=RDKIT_AVAILABLE,
        now=datetime.datetime.now(datetime.UTC) # Updated to timezone-aware
    )

def parse_nmr_signals(signal_input: str) -> Optional[int]:
    if not signal_input: return None
    try: signals = int(signal_input); return signals if signals >= 0 else None
    except ValueError: return None

def parse_nmr_ratio(ratio_input: str) -> Optional[List[int]]:
    if not ratio_input: return None
    try:
        parts = [int(p.strip()) for p in ratio_input.split(':') if p.strip()]
        valid_parts = [p for p in parts if p > 0]
        if len(valid_parts) != len(parts) or not valid_parts: return None
        return sorted(valid_parts)
    except ValueError: return None
    except Exception: return None

def format_sse(data: dict, event: Optional[str] = None) -> str:
    try:
        json_data = json.dumps(data)
    except TypeError as e:
        app.logger.error(f"Failed to serialize data for SSE: {data} - {e}")
        json_data = json.dumps({"type": "error", "message": f"Serialization error: {e}"})
    msg = f"data: {json_data}\n"
    if event: msg = f"event: {event}\n{msg}"
    return msg + "\n"

@app.route('/')
def index():
    app.logger.info("Rendering index page.")
    return render_template('index.html', categories=SMARTS_CATEGORIES)

# --- SSE Search Stream Route ---
@app.route('/search-stream')
def search_stream():
    formula = request.args.get('formula', '').strip()
    structural_constraint_keys = request.args.getlist('structural_constraints')
    nmr_signals_str = request.args.get('nmr_signals', '').strip()
    nmr_ratio_str = request.args.get('nmr_ratio', '').strip()

    @stream_with_context
    def generate_updates() -> Generator[str, None, None]:
        start_total_time = time.time()
        
        # --- BEGINNING OF CORRECTED SSE MESSAGE HANDLING ---
        _messages_to_yield_immediately: List[str] = [] # For messages generated by app.py itself
        _step_counter_for_client: int = 0

        # Callback for core_logic: appends formatted message to the list
        def core_logic_progress_callback(message_from_core: str):
            nonlocal _step_counter_for_client
            print(f"APP.PY (core_logic_callback): Received '{message_from_core[:50]}...'", flush=True)
            _step_counter_for_client += 1
            payload = {"step": _step_counter_for_client, "type": "log", "message": message_from_core}
            try:
                formatted_event = format_sse(payload)
                _messages_to_yield_immediately.append(formatted_event)
                print(f"APP.PY (core_logic_callback): Queued. List size: {len(_messages_to_yield_immediately)}", flush=True)
            except Exception as e:
                app.logger.error(f"APP.PY (core_logic_callback): Error formatting/queuing: {e}")
                # Optionally queue an error message about this internal issue
                error_payload = {"step": _step_counter_for_client, "type": "error", "message": f"Internal server error processing progress: {e}"}
                _messages_to_yield_immediately.append(format_sse(error_payload))


        # Helper to queue messages originating from app.py's stream logic
        def queue_app_event(message: str, msg_type: str = "status", extra_data: Optional[dict] = None):
            nonlocal _step_counter_for_client
            print(f"APP.PY (queue_app_event): Event '{msg_type}' - '{message[:50]}...'", flush=True)
            _step_counter_for_client += 1
            payload = {"step": _step_counter_for_client, "type": msg_type, "message": message}
            if extra_data: payload.update(extra_data)
            try:
                _messages_to_yield_immediately.append(format_sse(payload))
                print(f"APP.PY (queue_app_event): Queued. List size: {len(_messages_to_yield_immediately)}", flush=True)
            except Exception as e:
                app.logger.error(f"APP.PY (queue_app_event): Error formatting/queuing: {e}")


        # Helper to actually yield all queued messages
        def yield_queued_messages():
            # print(f"APP.PY (yield_queued_messages): Checking queue (size {len(_messages_to_yield_immediately)})", flush=True)
            flushed_count = 0
            while _messages_to_yield_immediately:
                msg = _messages_to_yield_immediately.pop(0)
                print(f"APP.PY (yield_queued_messages): YIELDING '{msg.strip()[:80]}...'", flush=True)
                yield msg
                flushed_count +=1
            
            if flushed_count > 0:
                # print(f"APP.PY (yield_queued_messages): Flushed {flushed_count} messages. Sleeping.", flush=True)
                sys.stdout.flush() 
                time.sleep(0.05) # Small pause after a burst of messages
        # --- END OF CORRECTED SSE MESSAGE HANDLING ---

        try:
            queue_app_event("Initiating search...", msg_type="start")
            yield from yield_queued_messages() # Initial yield

            # --- Input Validation ---
            queue_app_event("Validating input parameters...")
            # (Keep your existing validation logic)
            error_message = None
            warning_message = None # This will be for the results page, not necessarily for immediate SSE error
            search_params = {
                'formula': formula, 'structure_keys': structural_constraint_keys,
                'nmr_signals': None, 'nmr_ratio': None,
                'nmr_signals_str': nmr_signals_str, 'nmr_ratio_str': nmr_ratio_str
            }
            if not formula: error_message = "Molecular formula is required."
            elif not ('C' in formula.upper() and 'H' in formula.upper()): error_message = "Formula must contain at least C and H."
            
            nmr_signals = parse_nmr_signals(nmr_signals_str)
            if nmr_signals_str and nmr_signals is None: error_message = (error_message + " " if error_message else "") + "Invalid NMR signal count."
            search_params['nmr_signals'] = nmr_signals
            
            nmr_ratio = parse_nmr_ratio(nmr_ratio_str)
            if nmr_ratio_str and nmr_ratio is None: error_message = (error_message + " " if error_message else "") + "Invalid NMR ratio format."
            search_params['nmr_ratio'] = nmr_ratio

            if nmr_signals is not None and nmr_ratio is not None and len(nmr_ratio) != nmr_signals:
                 w_msg = "Warning: NMR signals count doesn't match ratio components. Applied independently."
                 warning_message = w_msg # For results page
                 queue_app_event(w_msg, msg_type="warning") # For immediate SSE warning
            
            yield from yield_queued_messages() # Yield validation messages

            if error_message:
                # For client-side display, error type is handled by the client's onmessage
                queue_app_event(error_message, msg_type="error") 
                # Also prepare for completion event to redirect to results with error
                results_params_on_error = search_params.copy()
                results_params_on_error['error'] = error_message
                final_url = url_for('results_display', **{k: v for k, v in results_params_on_error.items() if v is not None})
                _messages_to_yield_immediately.append(format_sse({"type": "redirect", "url": final_url, "message": "Error occurred"}, event="completion"))
                yield from yield_queued_messages()
                return

            structural_constraints_dict = {k: SMARTS_LIBRARY_DATA[k]['smarts'] for k in structural_constraint_keys if k in SMARTS_LIBRARY_DATA}

            # --- Execute Search: Step 1 (Formula + Structure) ---
            queue_app_event("Searching by formula and structure...")
            yield from yield_queued_messages() # Yield "Searching..." message before blocking call

            candidate_cids, struct_error = find_candidates_by_structure(
                formula, structural_constraints_dict, progress_callback=core_logic_progress_callback
            )
            # core_logic_progress_callback would have queued messages. Now yield them.
            yield from yield_queued_messages() 

            if struct_error:
                queue_app_event(f"Structural search failed: {struct_error}", msg_type="error")
                results_params_on_error = search_params.copy(); results_params_on_error['error'] = f"Structural search failed: {struct_error}"
                final_url = url_for('results_display', **{k: v for k, v in results_params_on_error.items() if v is not None})
                _messages_to_yield_immediately.append(format_sse({"type": "redirect", "url": final_url, "message": "Error occurred"}, event="completion"))
                yield from yield_queued_messages()
                return
            if candidate_cids is None: # Should be caught by struct_error, but as a safeguard
                queue_app_event("Unknown error during structure search.", msg_type="error")
                # ... similar completion redirect ...
                yield from yield_queued_messages()
                return

            if not candidate_cids:
                final_msg = "Search complete: No compounds found matching structural criteria."
                queue_app_event(final_msg, msg_type="complete", extra_data={"count": 0})
                results_params = search_params.copy(); results_params['cids'] = ""; results_params['total_found'] = 0; results_params['warning'] = warning_message
                final_url = url_for('results_display', **{k: v for k, v in results_params.items() if v is not None})
                _messages_to_yield_immediately.append(format_sse({"type": "redirect", "url": final_url, "message": final_msg}, event="completion"))
                yield from yield_queued_messages()
                return

            # --- Execute Search: Step 2 (NMR Filtering) ---
            final_cids = candidate_cids # Initialize final_cids
            nmr_applied = False
            if RDKIT_AVAILABLE and (search_params['nmr_signals'] is not None or search_params['nmr_ratio'] is not None):
                nmr_applied = True
                queue_app_event("Applying NMR filters...")
                yield from yield_queued_messages()

                filtered_cids, nmr_filter_warning_msg = filter_candidates_by_nmr(
                    candidate_cids, search_params['nmr_signals'], search_params['nmr_ratio'], progress_callback=core_logic_progress_callback
                )
                yield from yield_queued_messages() # Yield messages from NMR filtering

                if nmr_filter_warning_msg:
                    full_nmr_warning = (warning_message + "; " if warning_message else "") + nmr_filter_warning_msg
                    warning_message = full_nmr_warning # For results page
                    queue_app_event(f"NMR Warning: {nmr_filter_warning_msg}", msg_type="warning") # For SSE
                final_cids = filtered_cids
            else:
                if not RDKIT_AVAILABLE and (search_params['nmr_signals'] is not None or search_params['nmr_ratio'] is not None):
                     msg = "RDKit not available, NMR filters skipped."
                     warning_message = (warning_message + "; " if warning_message else "") + msg
                     queue_app_event(msg, msg_type="warning")
                elif search_params['nmr_signals'] is None and search_params['nmr_ratio'] is None:
                      queue_app_event("NMR filtering skipped: No constraints specified.")
            
            yield from yield_queued_messages() # Yield any messages from NMR skip logic


            # --- Final Check & Prepare Completion ---
            if not final_cids:
                 final_msg = "Search complete: No compounds matched all criteria after filtering." if nmr_applied else "Search complete: No compounds found." # Simplified
                 queue_app_event(final_msg, msg_type="complete", extra_data={"count": 0})
                 results_params = search_params.copy(); results_params['cids'] = ""; results_params['total_found'] = 0; results_params['warning'] = warning_message
                 final_url = url_for('results_display', **{k: v for k, v in results_params.items() if v is not None})
                 _messages_to_yield_immediately.append(format_sse({"type": "redirect", "url": final_url, "message": final_msg}, event="completion"))
                 yield from yield_queued_messages()
                 return

            # Success path
            final_count = len(final_cids)
            queue_app_event(f"Search completed successfully. Found {final_count} compounds.", msg_type="complete", extra_data={"count": final_count})

            results_params = search_params.copy()
            cids_limit_url = 500 # Max CIDs to pass in URL to avoid overly long URLs
            cids_to_pass_in_url = final_cids[:cids_limit_url]
            if len(final_cids) > len(cids_to_pass_in_url):
                 url_trunc_msg = f"Result list truncated in URL (passing {len(cids_to_pass_in_url)} of {len(final_cids)} CIDs)."
                 warning_message = (warning_message + "; " if warning_message else "") + url_trunc_msg
                 # Optionally, send this as an SSE warning too if desired:
                 # queue_app_event(url_trunc_msg, msg_type="warning")

            results_params['cids'] = ",".join(map(str, cids_to_pass_in_url))
            results_params['total_found'] = len(final_cids) # Always pass the true total
            results_params['warning'] = warning_message # Pass accumulated warnings
            
            results_params_cleaned = {k: v for k, v in results_params.items() if v is not None}
            final_url = url_for('results_display', **results_params_cleaned)
            
            _messages_to_yield_immediately.append(format_sse({"type": "redirect", "url": final_url, "message": "Redirecting to results..."}, event="completion"))
            yield from yield_queued_messages() # Yield the final "complete" and the "completion" event

            end_total_time = time.time()
            app.logger.info(f"SSE Stream processing completed in {end_total_time - start_total_time:.2f} seconds.")

        except Exception as e:
            app.logger.exception("Error during SSE stream generation (outer try-except):")
            # Attempt to yield a final error message to the client if the stream is still open
            try:
                # Create a payload for a standard message of type "error"
                error_payload_final = {"step": _step_counter_for_client + 1, 
                                       "type": "error", 
                                       "message": f"An unexpected server error occurred: {str(e)}"}
                yield format_sse(error_payload_final) # Yield as a standard message
                # Then, if you still want to attempt a redirect to an error-state results page:
                # final_error_url = url_for('results_display', error=f"Unexpected server error: {str(e)}")
                # yield format_sse({"type": "redirect", "url": final_error_url, "message": "Critical error"}, event="completion")
                sys.stdout.flush()
            except Exception as e_final_yield:
                app.logger.error(f"Could not yield final error message after outer exception: {e_final_yield}")

    response = Response(generate_updates(), mimetype='text/event-stream')
    response.headers['Cache-Control'] = 'no-cache, no-transform'
    response.headers['X-Accel-Buffering'] = 'no' # Important for Nginx if used
    response.headers['Connection'] = 'keep-alive'
    return response


# --- GET Route to Display Results ---
# (results_display route remains the same as in your original file)
@app.route('/results')
def results_display():
    # ... (your existing results_display logic) ...
    app.logger.info("Rendering results page.")
    formula = request.args.get('formula', '')
    structure_keys_str = request.args.get('structure_keys', '')
    nmr_signals_str = request.args.get('nmr_signals_str', '')
    nmr_ratio_str = request.args.get('nmr_ratio_str', '')
    cids_str = request.args.get('cids', '')
    total_found = request.args.get('total_found', type=int, default=0)
    warning_message_arg = request.args.get('warning', None) # Renamed to avoid conflict
    error_message_arg = request.args.get('error', None) # Renamed

    structure_keys = structure_keys_str.split(',') if structure_keys_str else []
    nmr_signals_parsed = parse_nmr_signals(nmr_signals_str)
    nmr_ratio_parsed = parse_nmr_ratio(nmr_ratio_str)
    search_params_display = {
        'formula': formula, 'structure_keys': structure_keys,
        'nmr_signals': nmr_signals_parsed, 'nmr_ratio': nmr_ratio_parsed,
        'nmr_signals_str': nmr_signals_str, 'nmr_ratio_str': nmr_ratio_str
    }
    final_cids = []
    # Use error_message_arg for errors passed via URL
    current_error = error_message_arg 
    if cids_str:
        try:
            final_cids = [int(cid) for cid in cids_str.split(',') if cid.isdigit()]
            if len(final_cids) != len([c for c in cids_str.split(',') if c]): # Check if all parts were digits
                 error_add = "Error parsing CID list from URL."
                 current_error = (current_error + "; " + error_add) if current_error else error_add
                 final_cids = [] 
        except ValueError:
            error_add = "Invalid CID format received in URL."
            current_error = (current_error + "; " + error_add) if current_error else error_add
            final_cids = []

    detailed_results = {}
    current_warning = warning_message_arg # Use warning_message_arg

    if final_cids and not current_error: # Only fetch details if no prior error and CIDs exist
        app.logger.info(f"Fetching details for display (top {min(len(final_cids), MAX_DETAILS_TO_SHOW)} CIDs).")
        cids_for_detail = final_cids[:MAX_DETAILS_TO_SHOW]
        try:
            detailed_results = fetch_compound_details(
                cids_for_detail, DETAIL_IMAGE_WIDTH, DETAIL_IMAGE_HEIGHT
            )
            if len(detailed_results) < len(cids_for_detail) and cids_for_detail:
                 det_warning = f"Could not fetch details for {len(cids_for_detail) - len(detailed_results)} top compounds."
                 current_warning = (current_warning + "; " + det_warning) if current_warning else det_warning
                 app.logger.warning(det_warning)
        except Exception as e_detail:
             error_add = f"Error fetching compound details: {e_detail}"
             current_error = (current_error + "; " + error_add) if current_error else error_add
             app.logger.exception("Error during detail fetching:")
    
    # Consolidate warnings about result list truncation
    if total_found > 0 and not final_cids and not current_error : # CIDs found but not passed (e.g. too many)
        list_too_long_warn = f"{total_found} results found, but list was too long to pass in URL."
        current_warning = (current_warning + "; " + list_too_long_warn) if current_warning else list_too_long_warn
    elif total_found != len(final_cids) and final_cids: # CIDs passed but truncated
        if current_warning is None or "Result list truncated in URL" not in current_warning:
            # This specific warning might have already been set by the stream logic
            trunc_warning = f"{total_found} results found, list in URL truncated to {len(final_cids)} CIDs."
            current_warning = (current_warning + "; " + trunc_warning) if current_warning else trunc_warning


    return render_template(
        'results.html', search_params=search_params_display, final_cids=final_cids,
        total_found=total_found, detailed_results=detailed_results,
        max_cids_summary=MAX_CIDS_SUMMARY, 
        error=current_error, # Pass the consolidated error
        warning=current_warning # Pass the consolidated warning
    )


# --- Main Execution ---
if __name__ == '__main__':
    print("-" * 50)
    print(" Starting PubChem Structural Isomer Finder Web App")
    print(" --> Using Gevent WSGI Server for SSE <--")
    print("-" * 50)

    if not RDKIT_AVAILABLE:
        print("\n!!! WARNING: RDKit not found. NMR features will be disabled. !!!\n")

    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s [%(name)s:%(lineno)d] %(message)s', force=True)
    app.logger.setLevel(logging.DEBUG) # Flask app logger
    logging.getLogger('werkzeug').setLevel(logging.INFO) 
    logging.getLogger('core_logic').setLevel(logging.DEBUG) # Your core_logic logger
    # logging.getLogger('urllib3').setLevel(logging.INFO) # Quieten urllib3 unless debugging it

    print(f"Flask App Log Level: {logging.getLevelName(app.logger.level)}")
    print(f"Core Logic Log Level: {logging.getLevelName(logging.getLogger('core_logic').level)}")
    print(f"Max details to show (images): {MAX_DETAILS_TO_SHOW}")

    try:
        from gevent.pywsgi import WSGIServer
        app.debug = False 
        print("Starting server with Gevent WSGIServer on http://0.0.0.0:5001")
        # You can pass a logger to WSGIServer, but Flask's app.logger is fine for app messages.
        # For WSGIServer's own access logs, you might configure its `log` argument if desired.
        http_server = WSGIServer(('0.0.0.0', 5001), app) 
        http_server.serve_forever()
    except ImportError:
        print("\n--- Gevent not found ---")
        print("Running with Flask's development server (SSE might be buffered).")
        print("For better SSE support, install gevent: pip install gevent")
        app.run(debug=True, host='0.0.0.0', port=5001, threaded=True) # Fallback